---
author: "Kim, Geunho"
date: 2020-04-11
draft: true
title: "분산 시스템의 파티셔닝에 대해서"
---

분산 시스템은 효과적인 부하 분산을 위해 데이터를 파티셔닝해서 저장한다.
즉, scalability를 얻기 위해서

하나의 레코드는 파티셔닝 전략에 따라 특정 파티션에 속하게 된다.
각 파티션은 하나의 작은 데이터베이스가 된다.

서로 다른 파티션은 다른 노드에 저장될 수 있으므로, 데이터가 다중 분산 노드의 디스크에 분산되어 저장될 수 있다.
데이터 질의는 분산된 노드로 요청을 보내고, 각 노드는 담당하는 파티션에 대해 각각 질의하므로 분산, 병렬 처리될 수 있다.
즉, 부하의 분산이 가능하다.

노드가 추가될 때?
노드가 삭제될 때?
Hot spot? (skewed?)
rebalancing이 필요함

파티셔닝 전략에 대해
키 범위(key range) 기준 파티셔닝
각 파티션에 최소~ 최대 값에 해당하는 키의 레코드를 할당
* range scan이 쉬워지는 이점이 있음
* 키를 연속적인 색인으로 간주, 질의 한번으로 관련 레코드 여러 개를 읽어들일 수 있음

해시 기준 파티셔닝
hot spot 방지를 위해 키의 해시값을 사용하는 방법
해시 함수가 암호적으로 강력할 필요는 없음 
내장 해시함수는 사용시 주의가 필요한데, Java의 경우 `Object.hashCode()`는 그냥 사용하면 서로 다른 프로세스에서 다른 값을 반화하기 때문에 사용해서는 안된다.
override해서 사용해야 함.
* 각 파티션을 균등하게 나눌 수 있음
* range scan이 불가
카산드라의 경우 복합 기본키를 지정해서, 첫 번째 키는 해시해서 파티션 결정에 사용. 첫 번째 컬럼만 고정 값을 지정하면 
나머지 키에 대해서는 range scan이 가능함

그럼에도 불구하고 hot spot이 발생핳 때?
특정 키에 대해 대량의 작업이 반복적으로 일어난다면, 그 키가 속한 파티션은 hot spot이 될 것.
이러한 키에 대해서 애플리케이션 레벨에서 조정이 필요한데,
* 키 끝에 임의의 10진수 두 개를 붙이면
* 그 키는 100개의 해시로 나뉘어 부하가 분산될 수 있음
* 단, 다시 읽어들일 때에도 100개의 파티션을 뒤져서 병합해야 함
* 특정 키에 대해서만 작업되도록 하는 것이 필요
* 이게 모두 애플리케이션 레벨의 관리가 필요한 부분..

보조 색인
레코드를 유일하게 식별하는 키와 다르게, 보조 색인은 특정 값이 발생한 항목을 검색하는 수단

문서(document) 기반 파티셔닝
각 파티션이 개별 보조 색인을 유지, 그 파티션에 해당하는 레코드만 담당. 이러한 특성으로 지역 색인(local index)라고도 한다.
그러나... 보조 색인된 항목으로 검색할 때, 모든 파티션에 질의를 보내서 병합해야하는 큰 비용이 발생
따라서 특정 파티션의 응답 지연으로 인한 꼬리 지연 시간 증폭이 발생하기 쉬움

용어(term) 기반 파티셔닝
보조 섹인을 그 용어를 기준으로 다시 파티셔닝해서 저장하는 것
즉, 특정 용어 구간은 단일 파티션에 존재하므로 효율적으로 읽기 작업을 할 수 있다.
전역 색인(global index)이라고도 불린다.
단, 단일 문서 저장시 지정된 색인이 여러 파티션에 영향을 줄 수 있으므로 쓰기가 느린 단점이 있음
일관성 유지를 고려한다면, 여러 노드에 대해 분산 트랜잭션을 수행해야 하는 문제가 있어서,
대부분 비동기로 갱신한다.




